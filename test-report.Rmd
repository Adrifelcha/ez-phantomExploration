---
title: "Exploring the role of process model parameters in phantom interactions on RTs"
author: "Adriana F. Chávez De la Peña and Joachim Vandekerckhove"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    cards: false
    highlight: tango
    fig_width: 12 
    fig_height: 8 
    css: src/custom.css
---

```{r, echo = FALSE, message = FALSE}
library(here)
library(knitr)
library(kableExtra) 
library(tidyverse)
source(here("src", "sample_summary-stats.R"))
library(R2jags)
```


# Introduction

Phantom interactions are scale-dependent statistically significant noncrossover interactions between two or more factors that disappear after appropriate scale transformation.

**Key characteristics:**

- **Scale-Dependent:** The interaction's presence or significance depends heavily on the scale used for the dependent variable.
- **Visual Cue:** On an interaction plot using the original scale, the lines representing the levels of one factor across the levels of another factor will be non-parallel but typically won't cross within the observed data range (hence "noncrossover"). After transformation, these lines often become (approximately) parallel.
- **Removable:** The interaction can often be "removed" by changing the scale, potentially simplifying the model interpretation to only main effects on the transformed scale.

Phantom interactions are an artifact of the original dependent variable measurement scale. They can't be used to conclude that the effect of one factor fundamentally changes depending on the level of another. As such, they highlight the importance of considering the appropriate scale for analyzing data, especially when effects might combine multiplicatively rather than purely additively.

# Test 1: <br>Single participant tested over multiple days and conditions

```{r}
# Simulation design settings:
J <- 2    # Design factors
L <- 2    # Levels per factor
K <- J*L  # Conditions
D <- 8    # Repeated observations (experimental sessions)
N <- 120  # Trials per condition
```

We generate data for a single participant in a binary decision task with $K =$ `r K` conditions defined by a simple `r L`-by-`r L` factorial design:

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Create the data frame
my_data <- data.frame(
  FactorB = c("FactorB1", "FactorB2"),
  FactorA1 = c("Cond 1", "Cond 3"),
  FactorA2 = c("Cond 2", "Cond 4")
)

# Generate the table using kable
kable(my_data, 
      col.names = c("", "FactorA1", "FactorA2"), # Set column names, empty for the first
      align = 'lcc') %>%                        # Align columns (left, center, center)
  kable_styling(bootstrap_options = c("striped", "bordered"), # Add styling
                full_width = FALSE)             # Prevent table from spanning full page width
```


For each condition $k$, we generate summary statistics for the choice and response time data using the EZ drift diffusion model (EZ-DDM). As such, the accuracy rate $\dot{A}_k$, mean response time $\dot{MRT}_k$, and response time variance $\dot{VRT}_k$ are modeled as:

$$\dot{A}_k, \dot{MRT}_k, \dot{VRT}_k \sim \mbox{EZDDM}(\nu_{k}, \alpha_{k}, \tau)$$

where $\nu$, $\alpha$, and $\tau$ are the parameters of the simple drift diffusion model (the drift rate, boundary separation, and non-decision time, respectively).

We generate $D =$ `r D` summary statistics per condition, as if the participant completed the task on $D$ experimental sessions.

## Set true parameter values

We define arbitrary values for the boundary separation and drift rate parameters in each experimental conditions such that **each parameter is only affected by a different main effect**.

```{r}
# Only Factor A has a main effect on the boundary separation
bound <- matrix(c(3,   5.5, 
                  3.05, 5.55), nrow = L, ncol = L, byrow = TRUE)
# Only Factor B has a main effect on the drift rate
drift <- matrix(c(0.7, 0.75, 
                  2.5, 2.45), nrow = L, ncol = L, byrow = TRUE)
```

```{r, echo = FALSE, fig.height = 4, fig.align = "center"}
layout(matrix(c(1,2), nrow = 1, ncol = 2))
par(mai = c(0.5,1,0.5,0.1), oma = c(0,0,0,0))
plot(c(0.5,1), bound[1,], type = "b", pch = 16, col = "red", ylim = c(0, max(bound)*1.2),
     ann = FALSE,axes = FALSE, xlim = c(0.4,1.1))
axis(1, at = c(0.5,1), labels = c("Factor A1", "Factor A2"))
axis(2, at = seq(0, max(bound)*1.2,length.out = 5), labels = round(seq(0, max(bound)*1.2,length.out = 5),1), las = 2)
points(c(0.5,1), bound[2,], type = "b", pch = 16, col = "blue")
legend("bottomright", legend = c("Factor B1", "Factor B2"), col = c("red", "blue"), pch = 16, bty = "n")
#mtext("Only Factor A has a main effect", side = 3, line = 0, font = 2)
mtext(expression(bold(paste("Boundary separation ", alpha))), side = 2, line = 2.5, font = 2, cex = 1.2)

plot(c(0.5,1), drift[1,], type = "b", pch = 16, col = "red", ylim = c(0, max(drift)*1.2),
     ann = FALSE,axes = FALSE, xlim = c(0.4,1.1))
axis(1, at = c(0.5,1), labels = c("Factor A1", "Factor A2"))
axis(2, at = seq(0, max(drift)*1.2,length.out = 5), labels = round(seq(0, max(drift)*1.2,length.out = 5),1), las = 2)
points(c(0.5,1), drift[2,], type = "b", pch = 16, col = "blue")
#mtext("Only Factor B has a main effect", side = 3, line = 0, font = 2)
mtext(expression(bold(paste("Drift rate ", nu))), side = 2, line = 2.5, font = 2, cex = 1.2)
```

We identify the parameter values used to simulate the summary statistics for each experimental condition per experimental session and store them in a list. 

```{r}
ddm_parameters <- list(
  bound = rep(as.vector(bound), D),  # Repeated over experimental sessions
  drift = rep(as.vector(drift), D),  # Repeated over experimental sessions
  nondt = rep(0.2, D*L*L)            # Same for all conditions and experimental sessions
)
```

So that the simulation design matrix ends up looking like this:

```{r, echo = FALSE}
FA <- rep(rep(paste("A",c(1,2), sep=""), each = L), D)
FB <- rep(paste("B",c(1,2), sep=""), L*D)
Session <- rep(1:D, each = K)

design <- data.frame("Drift" = ddm_parameters$drift, 
                     "Bound" = ddm_parameters$bound, 
                     "Nondt" = ddm_parameters$nondt,
                     "Factor A" = FA, "Factor B" = FB,
                     "Condition" = rep(NA, D*K),
                     "Session" = Session)

design$Condition <- 1
design$Condition[design$Factor.B == "B2" & design$Factor.A == "A1"] <- 2
design$Condition[design$Factor.B == "B1" & design$Factor.A == "A2"] <- 3
design$Condition[design$Factor.B == "B2" & design$Factor.A == "A2"] <- 4
head(design,8)
```

## Generate EZ summary statistics

We use our custom function `simSumStats()` to generate the EZ summary statistics for each experimental session:

```{r}
sum_stats <- simSumStats(ddm_parameters, N)
```

```{r, echo=FALSE}
full_data <- cbind(design, round(sum_stats, 4))
head(full_data,8)
```

When we plot the mean RTs simulated by condition from the selected true parameter values, we find a noncrossover interaction between Factor A and Factor B. This is an example of a phantom interaction, where the interaction plot shows that the mean RTs across the two levels of any of the two factors are different ($A1 < A2$, and $B1 > B2$), but the magnitude of said difference seems to be modulated by the level of the remaining factor (without being fundamentally or qualitatively affected).

```{r, echo=FALSE}
layout(matrix(c(1), nrow = 1, ncol = 1))
par(mai = c(1, 1, 0.5, 0.1), oma = c(0, 0, 0, 0)) 

jitter_factor <- 0.1 
colors_b <- c("red", "blue")
names(colors_b) <- c("B1", "B2")

means <- matrix(tapply(full_data$Mrt, full_data$Condition, mean), ncol=2)

plot(NULL, xlim = c(0.5, 2.5), ylim = range(full_data$Mrt, na.rm = TRUE) * c(0.95, 1.05),      
     xaxt = "n", las = 1, ann = FALSE)     
axis(1, at = c(1, 2), labels = c("A1", "A2"), cex.axis = 1.2)
points(jitter(as.numeric(factor(full_data$Factor.A[full_data$Factor.B == "B1"])), factor = jitter_factor),
       full_data$Mrt[full_data$Factor.B == "B1"], pch = 16, col = colors_b["B1"])
points(jitter(as.numeric(factor(full_data$Factor.A[full_data$Factor.B == "B2"])), factor = jitter_factor),
       full_data$Mrt[full_data$Factor.B == "B2"], pch = 16, col = colors_b["B2"])
points(c(1,2),means[1,], type="b", pch=16, cex=1.5, lty=2)
points(c(1,2),means[2,], type="b", pch=16, cex=1.5, lty=2)
#abline(h = 1.5, lty = 2, col = "gray80", lwd = 4)
mtext("Mean Reaction Time (Mrt)", side = 2, line = 2.7, font = 2, cex = 1.4)
mtext("Factor A", side = 1, line = 2.5, font = 2, cex = 1.4)
legend("topright", legend = c("Factor B1", "Factor B2"), col = colors_b, pch = 16, bty = "n", cex = 1.5)
```


For example, the mean RTs are higher on conditions with factor $A$ set to $A2$ than on conditions with factor $A$ set to $A1$, but this difference seems to be drastically attenuated when factor $B$ is set to $B2$ instead of $B1$.

## Parameter estimation using our Bayesian EZ DDM

We will now fit a Bayesian EZ DDM to the simulated data to explore the main and interaction effects of Factor A and Factor B on the boundary separation and drift rate parameters. <!--Here, we only show the JAGS model. The full R code can be found on the .Rmd file corresponding to this report. -->

### JAGS model

```{r}
modelFile <- here("output", "BUGS", "ezddm_model.bug")

model <- write("
model {
          ##################
          ####### Priors
          ##################                    
          drift_mu ~ dnorm(0,1)                      # Baseline drift rate
          drift_lambda ~ dgamma(2,1)
          drift_sigma = pow(drift_lambda, -0.5)
          bound_mu ~ dnorm(2,1)T(0,)                 # Baseline boundary separation
          bound_lambda ~ dgamma(2,1)
          bound_sigma = pow(bound_lambda, -0.5)
          nondt ~ dexp(1)                            # Participant-specific non-decision time  
                                        
          # Regression coefficients (2 main effects + 1 interaction)
          for(i in 1:3){                           
              gamma[i] ~ dnorm(0,1)                # Drift rate regression coefficients
              lambda[i] ~ dnorm(0,1)               # Boundary separation regression coefficients
          }      
          
          # Condition-specific drift rate and boundary separation
          for(j in 1:4){
              drift_pred[j] = drift_mu + gamma[1]*A[j]+gamma[2]*B[j]+gamma[3]*A[j]*B[j]
              bound_pred[j] = bound_mu + lambda[1]*A[j]+lambda[2]*B[j]+lambda[3]*A[j]*B[j]
          }
          
          #########################
          ####### Sampling model 
          ####### (for each experimental session)
          #########################          
          for (k in 1:length(meanRT)) {
              # Person-by-condition specificDM parameters                                    
              drift[k] ~ dnorm(drift_pred[cond[k]],drift_lambda)
              bound[k] ~ dnorm(bound_pred[cond[k]],bound_lambda)                  
      
              # Forward equations from EZ Diffusion
              ey[k]  = exp(-bound[k] * drift[k])
              Pc[k]  = 1 / (1 + ey[k])
              PRT[k] = 2 * pow(drift[k], 3) / bound[k] * pow(ey[k] + 1, 2) / (2 * -bound[k] * 
                      drift[k] * ey[k] - ey[k] * ey[k] + 1)
              MDT[k] = (bound[k] / (2 * drift[k])) * (1 - ey[k]) / (1 + ey[k])
              MRT[k] = MDT[k] + nondt
      
              # Sampling distributions for summary statistics
              correct[k] ~ dbin(Pc[k], nTrials[k])
              varRT[k]   ~ dnorm(1/PRT[k], 0.5*(nTrials[k]-1) * PRT[k] * PRT[k])
              meanRT[k]  ~ dnorm(MRT[k], PRT[k] * nTrials[k])
            }
}", modelFile)
```

### Run JAGS

```{r}
# General setup
n.chains  <- 4;      n.iter    <- 3500
n.burnin  <- 250;    n.thin    <- 1

# Pass data to JAGS
data_toJAGS <- list("nTrials"  =  rep(N, length(full_data$Mrt)),
                    "meanRT"   =  full_data$Mrt,
                    "varRT"    =  full_data$Vrt,
                    "correct"  =  full_data$A,
                    "cond"     =  full_data$Condition,
                    "A"   =  ifelse(full_data$Factor.A == "A1", 0, 1), 
                    "B"   =  ifelse(full_data$Factor.B == "B1", 0, 1))

# Specify parameters to keep track of
parameters <- c('gamma', 'lambda', 'drift', 'bound', 'drift_pred', 'bound_pred',
                "Pc", "PRT", "MRT")

# Prepare initial values
myinits <- rep(list(list()), n.chains)
for(i in 1:n.chains){
    myinits[[i]] <- list(drift = rnorm(length(data_toJAGS$nTrials),1,0.1))
}

start <- Sys.time()
samples <- jags(data=data_toJAGS,
                parameters.to.save=parameters,
                model=modelFile,
                n.chains=n.chains,  n.iter=n.iter,
                n.burnin=n.burnin,  n.thin=n.thin,
                DIC=T, inits=myinits)
end <- Sys.time()

cat("Time taken:", round(difftime(end, start, units = "secs"), 2), "seconds")
```


```{r, echo=FALSE}
source(here("src", "get_Rhat.R"))

rhats <- apply(samples$BUGSoutput$sims.array,3,getRhat)
rule <- 1.05
bad.Rhat <- which(rhats>rule)
test.rhat <- length(bad.Rhat) > 0
  if(test.rhat){
          par(mfrow=c(1,1))
          which.are.bad.Rhats <- names(bad.Rhat)
          hist(rhats, breaks = 50)
          abline(v=rule, col="red", lty=2)
          legend("top",paste("Rhat > ",rule," | ",
                             (round(nrow(bad.Rhat)/(length(as.vector(rhats))),5))*100,
                             "% of chains | ", length(which.are.bad.Rhats), " chains", sep=""), lty=2, col="red", cex=0.4)
          table(which.are.bad.Rhats)
  }else{      paste("No Rhat greater than ", rule, sep="")       }
```

```{r}
# Effects of instruction
gamma <- as.vector(samples$BUGSoutput$sims.list$gamma) # Main
lambda <- samples$BUGSoutput$sims.list$lambda # Interaction
# Fitted values / Predicted drift rates
drift_pred <- samples$BUGSoutput$sims.list$drift_pred
bound_pred <- samples$BUGSoutput$sims.list$bound_pred

# Load custom plotting functions
source(here("src", "plot_verticalHist.R"))
source(here("src", "plot_posteriors.R"))
```

```{r}
plot_estimates(samples, "drift")
```

```{r}
plot_estimates(samples, "bound")
```


# Test 2: Hierarchical model with population parameters

```{r}

```

# Custom functions

## Data generation

```{r, file = here("src", "sample_summary-stats.R")}
```


