---
title: "Exploring removable interactions on mean RT"
author: "Adriana F. Chávez De la Peña and Joachim Vandekerckhove"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    cards: false
    highlight: tango
    fig_width: 12 
    fig_height: 8 
---

```{r, echo = FALSE, message = FALSE}
library(here)
library(knitr)
library(kableExtra) 
library(tidyverse)
source(here("src", "sample_summary-stats.R"))
library(R2jags)
```


# Test 1: <br>Single participant tested over multiple days and conditions

```{r}
K <- 2 # Number of factor levels
D <- 8 # Number of days (repetitions)
N <- 120 # Number of trials per condition
```

We generate data for a single participant in a binary decision task where choice and response time data are recorded. Over the course of $D =$ `r D` days, the participant returns to the lab to complete the task, which consists of four different experimental conditions defined by a `r K`-by-`r K` factorial design:

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Create the data frame
my_data <- data.frame(
  FactorB = c("FactorB1", "FactorB2"),
  FactorA1 = c("Cond 1", "Cond 3"),
  FactorA2 = c("Cond 2", "Cond 4")
)

# Generate the table using kable
kable(my_data, 
      col.names = c("", "FactorA1", "FactorA2"), # Set column names, empty for the first
      align = 'lcc') %>%                        # Align columns (left, center, center)
  kable_styling(bootstrap_options = c("striped", "bordered"), # Add styling
                full_width = FALSE)             # Prevent table from spanning full page width
```

All conditions include the same number of trials, $N =$ `r N`.

## Set true parameter values

We select arbitrary parameter values for the boundary separation $\alpha$ and drift rate $\nu$ across all experimental conditions in such a way that each parameter is only affected by a given main effect.

```{r}
# Only Factor A has a main effect
bound <- matrix(c(3,   5.5, 
                  3.05, 5.55), nrow = K, ncol = K, byrow = TRUE)
# Only Factor B has a main effect
drift <- matrix(c(0.7, 0.75, 
                  2.5, 2.45), nrow = K, ncol = K, byrow = TRUE)
```

```{r, echo = FALSE, fig.height = 4, fig.align = "center"}
layout(matrix(c(1,2), nrow = 1, ncol = 2))
par(mai = c(0.5,1,0.5,0.1), oma = c(0,0,0,0))
plot(c(0.5,1), bound[1,], type = "b", pch = 16, col = "red", ylim = c(0, max(bound)*1.2),
     ann = FALSE,axes = FALSE, xlim = c(0.4,1.1))
axis(1, at = c(0.5,1), labels = c("Factor A1", "Factor A2"))
axis(2, at = seq(0, max(bound)*1.2,length.out = 5), labels = round(seq(0, max(bound)*1.2,length.out = 5),1), las = 2)
points(c(0.5,1), bound[2,], type = "b", pch = 16, col = "blue")
legend("bottomright", legend = c("Factor B1", "Factor B2"), col = c("red", "blue"), pch = 16, bty = "n")
#mtext("Only Factor A has a main effect", side = 3, line = 0, font = 2)
mtext(expression(bold(paste("Boundary separation ", alpha))), side = 2, line = 2.5, font = 2, cex = 1.2)

plot(c(0.5,1), drift[1,], type = "b", pch = 16, col = "red", ylim = c(0, max(drift)*1.2),
     ann = FALSE,axes = FALSE, xlim = c(0.4,1.1))
axis(1, at = c(0.5,1), labels = c("Factor A1", "Factor A2"))
axis(2, at = seq(0, max(drift)*1.2,length.out = 5), labels = round(seq(0, max(drift)*1.2,length.out = 5),1), las = 2)
points(c(0.5,1), drift[2,], type = "b", pch = 16, col = "blue")
#mtext("Only Factor B has a main effect", side = 3, line = 0, font = 2)
mtext(expression(bold(paste("Drift rate ", nu))), side = 2, line = 2.5, font = 2, cex = 1.2)
```

We store these parameter values across conditions, for each day of testing.

```{r}
ddm_parameters <- list(
  bound = rep(as.vector(bound), D),
  drift = rep(as.vector(drift), D),
  nondt = rep(0.2, D*K*K)  
)
```

```{r, echo = FALSE}
FA <- rep(rep(paste("A",c(1,2), sep=""), each = K), D)
FB <- rep(paste("B",c(1,2), sep=""), K*D)

design <- data.frame("Drift" = ddm_parameters$drift, 
                     "Bound" = ddm_parameters$bound, 
                     "Factor A" = FA, "Factor B" = FB)

design$Condition <- 1
design$Condition[design$Factor.B == "B2" & design$Factor.A == "A1"] <- 2
design$Condition[design$Factor.B == "B1" & design$Factor.A == "A2"] <- 3
design$Condition[design$Factor.B == "B2" & design$Factor.A == "A2"] <- 4
head(design,8)
```

## Generate EZ summary statistics

We use our custom function `simSumStats()` to generate the EZ summary statistics for each trial (i.e., accuracy rate `A`, mean RT `Mrt`, and RT variance `Vrt`).

```{r}
sum_stats <- simSumStats(ddm_parameters, N)
```

```{r, echo=FALSE}
full_data <- cbind(design, sum_stats)
head(full_data,8)
```

```{r, echo=FALSE}
layout(matrix(c(1), nrow = 1, ncol = 1))
par(mai = c(1, 1, 0.5, 0.1), oma = c(0, 0, 0, 0)) 

jitter_factor <- 0.1 
colors_b <- c("red", "blue")
names(colors_b) <- c("B1", "B2")

means <- matrix(tapply(full_data$Mrt, full_data$Condition, mean), ncol=2)

plot(NULL, xlim = c(0.5, 2.5), ylim = range(full_data$Mrt, na.rm = TRUE) * c(0.95, 1.05), 
     xlab = "Factor A", ylab = "Mean Reaction Time (Mrt)",
     main = "Generated Mean RTs by Condition",
     xaxt = "n", las = 1)     
axis(1, at = c(1, 2), labels = c("A1", "A2"))
points(jitter(as.numeric(factor(full_data$Factor.A[full_data$Factor.B == "B1"])), factor = jitter_factor),
       full_data$Mrt[full_data$Factor.B == "B1"], pch = 16, col = colors_b["B1"])
points(jitter(as.numeric(factor(full_data$Factor.A[full_data$Factor.B == "B2"])), factor = jitter_factor),
       full_data$Mrt[full_data$Factor.B == "B2"], pch = 16, col = colors_b["B2"])
points(c(1,2),means[1,], type="b", pch=16, cex=1.5, lty=2)
points(c(1,2),means[2,], type="b", pch=16, cex=1.5, lty=2)
legend("topright", legend = c("Factor B1", "Factor B2"), col = colors_b, pch = 16, bty = "n")
```

## Parameter estimation using our Bayesian EZ DDM

### JAGS model

```{r}
modelFile <- here("output", "BUGS", "ezddm_model.bug")

model <- write("
    model {
              ####### Priors
              drift_mu ~ dnorm(0,1)                     # Baseline drift rate
              drift_lambda ~ dgamma(2,1)
              drift_sigma = pow(drift_lambda, -0.5)
              bound_mu ~ dnorm(2,1)T(0,)                     # Baseline boundary separation
              bound_lambda ~ dgamma(2,1)
              bound_sigma = pow(bound_lambda, -0.5)
              nondt ~ dexp(1)

              # Regression coefficients
              for(i in 1:3){                  
                  gamma[i] ~ dnorm(0,1)                # Drift rate
                  lambda[i] ~ dnorm(0,1)               # Boundary separation
              }      
              
              for(j in 1:4){
                  drift_pred[j] = drift_mu + gamma[1]*A[j]+gamma[2]*B[j]+gamma[3]*A[j]*B[j]
                  bound_pred[j] = bound_mu + lambda[1]*A[j]+lambda[2]*B[j]+lambda[3]*A[j]*B[j]
              }
              
              ####### Sampling model
              for (k in 1:length(meanRT)) {
                  # Person-by-condition parameters for DM parameters                                    
                  drift[k] ~ dnorm(drift_pred[cond[k]],drift_lambda)
                  bound[k] ~ dnorm(bound_pred[cond[k]],bound_lambda)                  
          
                  # Forward equations from EZ Diffusion
                  ey[k]  = exp(-bound[k] * drift[k])
                  Pc[k]  = 1 / (1 + ey[k])
                  PRT[k] = 2 * pow(drift[k], 3) / bound[k] * pow(ey[k] + 1, 2) / (2 * -bound[k] * 
                           drift[k] * ey[k] - ey[k] * ey[k] + 1)
                  MDT[k] = (bound[k] / (2 * drift[k])) * (1 - ey[k]) / (1 + ey[k])
                  MRT[k] = MDT[k] + nondt
          
                  # Sampling distributions for summary statistics
                  correct[k] ~ dbin(Pc[k], nTrials[k])
                  varRT[k]   ~ dnorm(1/PRT[k], 0.5*(nTrials[k]-1) * PRT[k] * PRT[k])
                  meanRT[k]  ~ dnorm(MRT[k], PRT[k] * nTrials[k])
                }
    }", modelFile)
```

### JAGS setup

```{r, echo=FALSE}
# General setup
n.chains  <- 4;      n.iter    <- 5000
n.burnin  <- 250;    n.thin    <- 1

# Pass data to JAGS
data_toJAGS <- list("nTrials"  =  rep(N, length(full_data$Mrt)),
                    "meanRT"   =  full_data$Mrt,
                    "varRT"    =  full_data$Vrt,
                    "correct"  =  full_data$A,
                    "cond"     =  full_data$Condition,
                    "A"   =  as.integer(full_data$Factor.A)-1, 
                    "B"   =  as.integer(full_data$Factor.B)-1)

# Specify parameters to keep track of
parameters <- c('gamma', 'lambda', 'drift', 'bound', 'drift_pred', 'bound_pred',
                "Pc", "PRT", "MRT")

# Prepare initial values
myinits <- rep(list(list()), n.chains)
for(i in 1:n.chains){
    myinits[[i]] <- list(drift = rnorm(length(data_toJAGS$nTrials),1,0.1))
}
```

### JAGS run

```{r}
start <- Sys.time()
samples <- jags(data=data_toJAGS,
                parameters.to.save=parameters,
                model=modelFile,
                n.chains=n.chains,  n.iter=n.iter,
                n.burnin=n.burnin,  n.thin=n.thin,
                DIC=T, inits=myinits)
end <- Sys.time()

cat("Time taken:", round(difftime(end, start, units = "secs"), 2), "seconds")
```


```{r, echo=FALSE}
source(here("src", "get_Rhat.R"))

rhats <- apply(samples$BUGSoutput$sims.array,3,getRhat)
rule <- 1.05
bad.Rhat <- which(rhats>rule)
test.rhat <- length(bad.Rhat) > 0
  if(test.rhat){
          par(mfrow=c(1,1))
          which.are.bad.Rhats <- names(bad.Rhat)
          hist(rhats, breaks = 50)
          abline(v=rule, col="red", lty=2)
          legend("top",paste("Rhat > ",rule," | ",
                             (round(nrow(bad.Rhat)/(length(as.vector(rhats))),5))*100,
                             "% of chains | ", length(which.are.bad.Rhats), " chains", sep=""), lty=2, col="red", cex=0.4)
          table(which.are.bad.Rhats)
  }else{      paste("No Rhat greater than ", rule, sep="")       }
```

```{r}
# Effects of instruction
gamma <- as.vector(samples$BUGSoutput$sims.list$gamma) # Main
lambda <- samples$BUGSoutput$sims.list$lambda # Interaction
# Fitted values / Predicted drift rates
drift_pred <- samples$BUGSoutput$sims.list$drift_pred
bound_pred <- samples$BUGSoutput$sims.list$bound_pred

# Load custom plotting functions
source(here("src", "plot_verticalHist.R"))
source(here("src", "plot_posteriors.R"))
```

```{r}
plot_estimates(drift_pred)
```

```{r}
plot_estimates(bound_pred)
```


# Test 2: Hierarchical model with population parameters

```{r}

```

# Custom functions

## Data generation

```{r, file = here("src", "sample_summary-stats.R")}
```


